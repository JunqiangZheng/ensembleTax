The ensembleTax R package
================
D Catlett
8/25/2020

ensembleTax overview
====================

ensembleTax is an R package that allows incorporation of information from multiple taxonomic assignment algorithms and/or reference databases to compute ensemble taxonomic assignments for ASVs/OTUs generated by common marker gene sequence analyses. The package was built to conveniently compliment the dada2 R package and pipeline, but can be used with any combination of taxonomic assignment algorithm and reference database assuming the output taxonomic assignments can be read into R and formatted properly.

Here you can find instructions for downloading and installing the ensembleTax package, and a brief demonstration of a sample ensembleTax "pipeline".

Please ask questions and/or report bugs on the issue-tracker associated with this repository. Contributions of R-able wrappers or implementations of additional taxonomic assignment algorithms and/or reference database taxonomic nomenclatures are welcome.

The problem(s) addressed by ensembleTax
---------------------------------------

Taxonomic assignment of marker gene sequences is a critical step of marker gene workflows as it imparts ecological significance and understanding to genetic data.

Many taxonomic assignment algorithms have been proposed to assign taxonomy to marker gene sequences (or OTUs/ASVs). Similarly, analysts are often forced to choose from one of several reference databases containing representative marker gene sequences with known taxonomic identities. The "best" assignment algorithm and/or reference database for a particular scientific question is often not obvious. To complicate things further, different reference databases generally do not share consistent taxonomic naming or ranking conventions.

ensembleTax solves this problem by providing flexible algorithms that synthesize information from multiple taxonomic assignment algorithm/reference database combinations and compute a single ensemble taxonomic assignment for each ASV/OTU in a marker gene data set.

Download instructions
---------------------

The ensembleTax package is available on Github and ... To install from Github, first install ensembleTax's dependencies from CRAN and Bioconductor (and install Bioconductor if you don't have it), then use devtools to install from Github as follows:

``` r
install.packages(c("dplyr", "stringr", "usethis"))
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(version = "3.11")
BiocManager::install(c("DECIPHER", "Biostrings"))

library(devtools)
devtools::install_github("dcat4/ensembleTax")
packageVersion("ensembleTax")
```

ensembleTax algorithms
----------------------

The core algorithms employed by ensembleTax are *taxmapper* and *ensembleTax*. *taxmapper* maps, or 'translates', one taxonomic nomenclature onto another by exact name matching. *taxmapper* is rank-agnostic, meaning it does not consider the hierarchical structure of a taxonomy and assumes that a taxonomic name means the same thing regardless of which reference database employs it.

*ensembleTax* computes ensemble taxonomic assignments based on assignments determined by any number of individual taxonomic assignment algorithm/reference database combinations. Several parameters allow the user to control trade-offs in the accuracy vs. resolution of ensemble taxonomic assignments.

Additional functions are included for pre-processing taxonomic assignments generated by specific taxonomic assignment algorithms and reference databases. These functions are designed to conveniently plug in downstream of the dada2 pipeline, but other pipelines may be used if the data is formatted properly for use with *taxmapper* and/or *ensembleTax*.

The taxonomic assignment algorithms explicitly supported by ensembleTax are:

1.  bayesian classifier as implemented in dada2's assignTaxonomy.
2.  idtaxa algorithm as implemented in DECIPHER.

Supported reference databases include:

1.  Silva SSU NR reference database v138 (silva).
2.  Protistan Ribosomal Reference database v4.12.0 (pr2).

Note that other databases may still be used with ensembleTax, but they must be mapped onto the taxonomic nomenclatures employed by Silva and/or pr2 using *taxmapper*, or the user must extract all unique taxonomic assignments from the database and format them properly for use with *taxmapper*.

### ensembleTax 'pipeline' demonstration

Here we step through a simple example of an ensembleTax workflow to compute ensemble taxonomic assignments for a small set of 18S-V9 protist ASVs.

First, load some data included with the ensembleTax package. These are outputs of dada2's assignTaxonomy implemented against pr2, and of DECIPHER's idtaxa implemented against both pr2 and silva. The rubric.sample is an example of a "rubric", which ensembleTax uses to track ASV-identifying information. The rubric is a DNAStringSet (see the Biostrings package) object produced by extracting ASV sequences from the seqtab used by dada2, and giving them arbitrary names (like sv1, sv2, etc).

``` r
library("ensembleTax")
library("Biostrings")
```

    ## Loading required package: BiocGenerics

    ## Loading required package: parallel

    ## 
    ## Attaching package: 'BiocGenerics'

    ## The following objects are masked from 'package:parallel':
    ## 
    ##     clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    ##     clusterExport, clusterMap, parApply, parCapply, parLapply,
    ##     parLapplyLB, parRapply, parSapply, parSapplyLB

    ## The following objects are masked from 'package:stats':
    ## 
    ##     IQR, mad, sd, var, xtabs

    ## The following objects are masked from 'package:base':
    ## 
    ##     anyDuplicated, append, as.data.frame, basename, cbind, colnames,
    ##     dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
    ##     grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget,
    ##     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
    ##     rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply,
    ##     union, unique, unsplit, which, which.max, which.min

    ## Loading required package: S4Vectors

    ## Loading required package: stats4

    ## 
    ## Attaching package: 'S4Vectors'

    ## The following object is masked from 'package:base':
    ## 
    ##     expand.grid

    ## Loading required package: IRanges

    ## Loading required package: XVector

    ## 
    ## Attaching package: 'Biostrings'

    ## The following object is masked from 'package:base':
    ## 
    ##     strsplit

``` r
data("idtax.pr2.sample")
data("idtax.silva.sample")
data("bayes.sample")
data("rubric.sample")
```

If you want to see what they look like, do this:

``` r
head(idtax.pr2.sample)
head(idtax.silva.sample)
head(bayes.sample)
head(rubric.sample)
```

#### ensembleTax pre-processing

We see from the above that the data structures returned by our two taxonomic assignment algorithms are different. It is critically important that the order of sequences in the rubric and in the idtaxa-returned Taxon object are the same. idtaxa does not return sequence names, but if you did not alter the order of your sequences as you provided them to idtaxa and/or DNAStringSet when creating your rubric, the ordering should be preserved and you should be good to go.

Here we'll run these tables through ensembleTax's pre-processing functions. Supplying a rubric allows ensembleTax to give each taxonomy table the same ASV- identifying information and to better track and organize your data.

``` r
idtax.pr2.pretty <- idtax2df(idtax.pr2.sample, 
                             db = "pr2", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
idtax.silva.pretty <- idtax2df(idtax.silva.sample, 
                             db = "silva", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
bayes.pr2.pretty <- bayestax2df(bayes.sample, 
                             db = "pr2", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
```

Again if you want to view the data, do this:

``` r
head(idtax.pr2.pretty)
head(idtax.silva.pretty)
head(bayes.pr2.pretty)
```

We see that each taxonomy table is now a dataframe sorted by the column "svN".

#### The taxmapper algorithm

After pre-processing our taxonomic assignment data sets above, we see we still can't make apples-to-apples comparisons between the "idtax-silva" table and the two others because they employ different ranking and (though this may not be as obvious) naming conventions. *taxmapper* was created to solve this problem.

Here we'll use taxmapper to 'translate' the idtax-silva taxonomic assignments onto the same taxonomic nomenclature as the other two tables.

``` r
idtax.silva.mapped2pr2 <- taxmapper(idtax.silva.pretty,
                      tt.ranks = colnames(idtax.silva.pretty)[3:ncol(idtax.silva.pretty)],
                      tax2map2 = "pr2",
                      exceptions = c("Archaea", "Bacteria"),
                      ignore.format = TRUE,
                      synonym.file = "default",
                      streamline = TRUE,
                      outfilez = NULL)
```

Inspection of the mapped taxonomy table shows that it now mirrors the naming and ranking conventions of the other two taxonomy tables.

#### The ensembleTax algorithm

Now we have three different taxonomy tables with independent taxonomic assignments for each ASV in our example data set. From these we can compute ensemble taxonomic assignments with the *ensembleTax* algorithm.

Here's a run with the default parameters:

``` r
xx <- list(idtax.pr2.pretty, idtax.silva.mapped2pr2, bayes.pr2.pretty)
names(xx) <- c("idtax-pr2", "idtax-silva", "bayes-pr2")
eTax1 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = "none", 
                     count.na=TRUE, 
                     assign.threshold = 0, 
                     weights=rep(1,length(xx)))
head(eTax1)
```

    ##       svN
    ## 1 sv14136
    ## 2 sv17278
    ## 3 sv20747
    ## 4  sv3579
    ## 5  sv4298
    ##                                                                                                                                  ASV
    ## 1     ACACCTACCAATTGAATGGTCCGGTGAGGACTCGGATTGTGGTTTAGCTCCTTCATTGGGGCCTGACTGCAAGAACTTGTCCGAACCTTATCATTTAGAGGAAGGTGAAGTTGTAACAAGGTTTCC
    ## 2    GCACCTACCGATTGAACCATACGGTGAGGTCCTCGGATTTCATGAATCGACCTTCACTGGGAGATTCGTGAGAGAAGTTGCCCAAACCTCGTGGTTTAGAGGAAGGTGAAGTCGTAACAAGGTTTCC
    ## 3      GCACCCACCGATTGAAAAGCCCGGTGAAGAATCGGGATTGTAGCGTTGTCCTTCATTGGACATTGCCGTGAGAACCTTTCTGAACCTTGTTTTTTAGAGGAAGGTGAAGTCGTAACAAGGTCTCT
    ## 4 ACTCCTACCAATTGAATGATCCATGAAGTGTTTGGATTACATTGAAGATGGTGGTTTGCCGCTGTCGACGTCATGAGAAGTTCATTGAACCTTATCATTTAGAGGAAGGAGAAGTCATAACAAGGTTACC
    ## 5       GCACCTACCGATTGAATGGTCCGGTGAGATCTTCGGACTGCAGCGAAAGTCAGCAATGAGTTAGTCGCGGAAAGTTGATCAAACCTTACCATTTAGAGGAAGGTGAAGTCGTAACAAGGTTTCC
    ##     kingdom    supergroup   division           class             order
    ## 1 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 2 Eukaryota Stramenopiles Ochrophyta          MOCH-2              <NA>
    ## 3 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 4 Eukaryota          <NA>       <NA>            <NA>              <NA>
    ## 5 Eukaryota Stramenopiles   Opalozoa          MAST-3           MAST-3B
    ##                       family       genus species
    ## 1 Polar-centric-Mediophyceae        <NA>    <NA>
    ## 2                       <NA>        <NA>    <NA>
    ## 3 Polar-centric-Mediophyceae Chaetoceros    <NA>
    ## 4                       <NA>        <NA>    <NA>
    ## 5                       <NA>        <NA>    <NA>

We see that the assignments made at the highest frequency across the 3 assignment algorithms are assigned as the ensemble taxonomic assignment. *NA* is counted as a taxonomic name because we've set *count.na = TRUE*.

We'll get different ensemble taxonomic assignments if we set *count.na = FALSE*, as you can see below:

``` r
xx <- list(idtax.pr2.pretty, idtax.silva.mapped2pr2, bayes.pr2.pretty)
names(xx) <- c("idtax-pr2", "idtax-silva", "bayes-pr2")
eTax2 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = "none", 
                     count.na=TRUE, 
                     assign.threshold = 0, 
                     weights=rep(1,length(xx)))
head(eTax2)
```

    ##       svN
    ## 1 sv14136
    ## 2 sv17278
    ## 3 sv20747
    ## 4  sv3579
    ## 5  sv4298
    ##                                                                                                                                  ASV
    ## 1     ACACCTACCAATTGAATGGTCCGGTGAGGACTCGGATTGTGGTTTAGCTCCTTCATTGGGGCCTGACTGCAAGAACTTGTCCGAACCTTATCATTTAGAGGAAGGTGAAGTTGTAACAAGGTTTCC
    ## 2    GCACCTACCGATTGAACCATACGGTGAGGTCCTCGGATTTCATGAATCGACCTTCACTGGGAGATTCGTGAGAGAAGTTGCCCAAACCTCGTGGTTTAGAGGAAGGTGAAGTCGTAACAAGGTTTCC
    ## 3      GCACCCACCGATTGAAAAGCCCGGTGAAGAATCGGGATTGTAGCGTTGTCCTTCATTGGACATTGCCGTGAGAACCTTTCTGAACCTTGTTTTTTAGAGGAAGGTGAAGTCGTAACAAGGTCTCT
    ## 4 ACTCCTACCAATTGAATGATCCATGAAGTGTTTGGATTACATTGAAGATGGTGGTTTGCCGCTGTCGACGTCATGAGAAGTTCATTGAACCTTATCATTTAGAGGAAGGAGAAGTCATAACAAGGTTACC
    ## 5       GCACCTACCGATTGAATGGTCCGGTGAGATCTTCGGACTGCAGCGAAAGTCAGCAATGAGTTAGTCGCGGAAAGTTGATCAAACCTTACCATTTAGAGGAAGGTGAAGTCGTAACAAGGTTTCC
    ##     kingdom    supergroup   division           class             order
    ## 1 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 2 Eukaryota Stramenopiles Ochrophyta          MOCH-2              <NA>
    ## 3 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 4 Eukaryota          <NA>       <NA>            <NA>              <NA>
    ## 5 Eukaryota Stramenopiles   Opalozoa          MAST-3           MAST-3B
    ##                       family       genus species
    ## 1 Polar-centric-Mediophyceae        <NA>    <NA>
    ## 2                       <NA>        <NA>    <NA>
    ## 3 Polar-centric-Mediophyceae Chaetoceros    <NA>
    ## 4                       <NA>        <NA>    <NA>
    ## 5                       <NA>        <NA>    <NA>

Sickarooni. Check out the other .md links in this repo if you want to see more example analysis. Otherwise happy assigning!
