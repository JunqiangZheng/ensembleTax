The ensembleTax R package
================
D Catlett
8/25/2020

# ensembleTax overview

ensembleTax is an R package that allows incorporation of information from multiple taxonomic assignment algorithms and/or reference databases to compute ensemble taxonomic assignments for ASVs/OTUs generated by common marker gene sequence analyses. The package was built to conveniently compliment the dada2 R package and pipeline, but can be used with any combination of taxonomic assignment algorithm and reference database assuming the output taxonomic assignments can be read into R and formatted properly.

Here you can find instructions for downloading and installing the ensembleTax package, and a brief demonstration of a sample ensembleTax "pipeline".

Please ask questions and/or report bugs on the issue-tracker associated with this repository. Contributions of R-able wrappers or implementations of additional taxonomic assignment algorithms and/or reference database taxonomic nomenclatures are welcome.

## The problem(s) addressed by ensembleTax

Taxonomic assignment of marker gene sequences is a critical step of marker gene workflows as it imparts ecological significance and understanding to genetic data.

Many taxonomic assignment algorithms have been proposed to assign taxonomy to marker gene sequences (or OTUs/ASVs). Similarly, analysts are often forced to choose from one of several reference databases containing representative marker gene sequences with known taxonomic identities. The "best" assignment algorithm and/or reference database for a particular scientific question is often not obvious. To complicate things further, different reference databases generally do not share consistent taxonomic naming or ranking conventions.

ensembleTax solves this problem by providing flexible algorithms that synthesize information from multiple taxonomic assignment algorithm/reference database combinations and compute a single ensemble taxonomic assignment for each ASV/OTU in a marker gene data set.

## Download instructions

The ensembleTax package is available on Github and CRAN. To install from Github, first install ensembleTax's dependencies from CRAN and Bioconductor (and install Bioconductor if you don't have it), then use devtools to install from Github as follows:

``` r
install.packages(c("dplyr", "stringr", "usethis", "devtools"))
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install(version = "3.11")
BiocManager::install(c("DECIPHER", "Biostrings"))

library(devtools)
devtools::install_github("dcat4/ensembleTax", build_manual = TRUE, build_vignettes = TRUE)
packageVersion("ensembleTax")
```

Alternatively, you can install from CRAN by doing:

``` r
install.packages(c("ensembleTax"))
packageVersion("ensembleTax")
```

## ensembleTax algorithms

The core algorithms employed by ensembleTax are *taxmapper* and *ensembleTax*. *taxmapper* maps, or 'translates', one taxonomic nomenclature onto another by exact name matching. *taxmapper* is rank-agnostic, meaning it does not consider the hierarchical structure of a taxonomy and assumes that a taxonomic name means the same thing regardless of which reference database employs it.

*ensembleTax* computes ensemble taxonomic assignments based on assignments determined by any number of individual taxonomic assignment algorithm/reference database combinations. Several parameters allow the user to control trade-offs in the accuracy vs. resolution of ensemble taxonomic assignments.

Additional functions are included for pre-processing taxonomic assignments generated by specific taxonomic assignment algorithms and reference databases. These functions are designed to conveniently plug in downstream of the dada2 pipeline, but other pipelines may be used if the data is formatted properly for use with *taxmapper* and/or *ensembleTax*.

The outputs of the following taxonomic assignment algorithms are explicitly supported by ensembleTax:

1.  RDP bayesian classifier as implemented in dada2's assignTaxonomy.
2.  idtaxa algorithm as implemented in DECIPHER.

Supported reference databases include:

1.  Silva SSU NR reference database v138 (silva).
2.  Protistan Ribosomal Reference database v4.12.0 (pr2).
3.  RDP train set v16
4.  GreenGenes v13.8 clustered at 97% similarity

Note that other databases may still be used with ensembleTax, but they must be mapped onto the taxonomic nomenclatures employed by one of the above supported databases using *taxmapper*, or the user must extract all unique taxonomic assignments from the database and format them properly for use with *taxmapper*.

A vignette that shows how to extract taxonomic assignments from a database not supported by the ensembleTax package can be found here: <https://github.com/dcat4/ensembleTax/blob/master/add_tax_dbs.md>

A vignette that shows how to incorporate taxonomic assignments produced outside of R into an ensembleTax workflow can be found here: <https://github.com/dcat4/ensembleTax/blob/master/add_tax_tab_from_csv.md>

### ensembleTax 'pipeline' demonstration

Here we step through a simple example of an ensembleTax workflow to compute ensemble taxonomic assignments for a small set of 18S-V9 protist ASVs.

First, load some data included with the ensembleTax package. These are outputs of dada2's assignTaxonomy implemented against pr2, and of DECIPHER's idtaxa implemented against both pr2 and silva. The rubric.sample is an example of a "rubric", which ensembleTax uses to track ASV-identifying information. The rubric is a DNAStringSet (see the Biostrings package) object produced by extracting ASV sequences from the seqtab used by dada2, and giving them arbitrary names (like sv1, sv2, etc).

``` r
library("ensembleTax")
library("Biostrings")
```

    ## Loading required package: BiocGenerics

    ## Loading required package: parallel

    ## 
    ## Attaching package: 'BiocGenerics'

    ## The following objects are masked from 'package:parallel':
    ## 
    ##     clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
    ##     clusterExport, clusterMap, parApply, parCapply, parLapply,
    ##     parLapplyLB, parRapply, parSapply, parSapplyLB

    ## The following objects are masked from 'package:stats':
    ## 
    ##     IQR, mad, sd, var, xtabs

    ## The following objects are masked from 'package:base':
    ## 
    ##     anyDuplicated, append, as.data.frame, basename, cbind, colnames,
    ##     dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
    ##     grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget,
    ##     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
    ##     rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply,
    ##     union, unique, unsplit, which.max, which.min

    ## Loading required package: S4Vectors

    ## Loading required package: stats4

    ## 
    ## Attaching package: 'S4Vectors'

    ## The following object is masked from 'package:base':
    ## 
    ##     expand.grid

    ## Loading required package: IRanges

    ## Loading required package: XVector

    ## 
    ## Attaching package: 'Biostrings'

    ## The following object is masked from 'package:base':
    ## 
    ##     strsplit

``` r
data("idtax.pr2.sample")
data("idtax.silva.sample")
data("bayes.sample")
data("rubric.sample")
```

If you want to see what they look like, do this:

``` r
head(idtax.pr2.sample)
head(idtax.silva.sample)
head(bayes.sample)
head(rubric.sample)
```

#### ensembleTax pre-processing

We see from the above that the data structures returned by our two taxonomic assignment algorithms are different. It is critically important that the order of sequences in the rubric and in the idtaxa-returned Taxon object are the same. idtaxa does not return sequence names, but if you did not alter the order of your sequences as you provided them to idtaxa and/or DNAStringSet when creating your rubric, the ordering should be preserved and you should be good to go.

Here we'll run these tables through ensembleTax's pre-processing functions. Supplying a rubric allows ensembleTax to give each taxonomy table the same ASV-identifying information and to better track and organize your data.

``` r
idtax.pr2.pretty <- idtax2df(idtax.pr2.sample, 
                             db = "pr2", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
idtax.silva.pretty <- idtax2df(idtax.silva.sample, 
                             db = "silva", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
bayes.pr2.pretty <- bayestax2df(bayes.sample, 
                             db = "pr2", 
                             ranks = NULL,
                             boot = 50,
                             rubric = rubric.sample,
                             return.conf = FALSE)
```

Again to view the data, do this:

``` r
# remove ASV columns from tax tables for easier viewing:
idtax.pr2.pretty <- idtax.pr2.pretty[ , -which(names(idtax.pr2.pretty) %in% c("ASV"))]
idtax.silva.pretty <- idtax.silva.pretty[ , -which(names(idtax.silva.pretty) %in% c("ASV"))]
bayes.pr2.pretty <- bayes.pr2.pretty[ , -which(names(bayes.pr2.pretty) %in% c("ASV"))]

head(idtax.pr2.pretty)
```

    ##       svN   kingdom    supergroup   division           class             order
    ## 1 sv14136 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 2 sv17278 Eukaryota Stramenopiles Ochrophyta            <NA>              <NA>
    ## 3 sv20747 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 4  sv3579      <NA>          <NA>       <NA>            <NA>              <NA>
    ## 5  sv4298 Eukaryota Stramenopiles       <NA>            <NA>              <NA>
    ##                       family       genus species
    ## 1 Polar-centric-Mediophyceae        <NA>    <NA>
    ## 2                       <NA>        <NA>    <NA>
    ## 3 Polar-centric-Mediophyceae Chaetoceros    <NA>
    ## 4                       <NA>        <NA>    <NA>
    ## 5                       <NA>        <NA>    <NA>

``` r
head(idtax.silva.pretty)
```

    ##       svN    domain       phylum   class order family genus
    ## 1 sv14136 Eukaryota         <NA>    <NA>  <NA>   <NA>  <NA>
    ## 2 sv17278 Eukaryota Eukaryota_ph  MOCH-2  <NA>   <NA>  <NA>
    ## 3 sv20747 Eukaryota         <NA>    <NA>  <NA>   <NA>  <NA>
    ## 4  sv3579 Eukaryota         <NA>    <NA>  <NA>   <NA>  <NA>
    ## 5  sv4298 Eukaryota       MAST-3 MAST-3B  <NA>   <NA>  <NA>

``` r
head(bayes.pr2.pretty)
```

    ##       svN   kingdom     supergroup     division           class
    ## 1 sv14136 Eukaryota  Stramenopiles   Ochrophyta Bacillariophyta
    ## 2 sv17278 Eukaryota  Stramenopiles   Ochrophyta          MOCH-2
    ## 3 sv20747 Eukaryota  Stramenopiles   Ochrophyta Bacillariophyta
    ## 4  sv3579 Eukaryota Archaeplastida Streptophyta   Embryophyceae
    ## 5  sv4298 Eukaryota  Stramenopiles     Opalozoa          MAST-3
    ##               order                     family       genus        species
    ## 1 Bacillariophyta_X Polar-centric-Mediophyceae  Minidiscus Minidiscus_sp.
    ## 2          MOCH-2_X                  MOCH-2_XX  MOCH-2_XXX MOCH-2_XXX_sp.
    ## 3 Bacillariophyta_X Polar-centric-Mediophyceae Chaetoceros           <NA>
    ## 4   Embryophyceae_X           Embryophyceae_XX        <NA>           <NA>
    ## 5           MAST-3B                  MAST-3B_X  MAST-3B_XX MAST-3B_XX_sp.

We see that each taxonomy table is now a dataframe sorted by the column "svN".

#### The taxmapper algorithm

After pre-processing our taxonomic assignment data sets above, we see we still can't make apples-to-apples comparisons between the "idtax-silva" table and the other two because they employ different ranking and (though this may not be as obvious) naming conventions. *taxmapper* was created to solve this problem.

Here we'll use *taxmapper* to 'translate' the idtax-silva taxonomic assignments onto the same taxonomic nomenclature as the other two tables.

Note that if you want to use your own custom synonym.file, there's a vignette showing how to do this here: <https://github.com/dcat4/ensembleTax/blob/master/how_to_add_synonyms.md>

``` r
idtax.silva.mapped2pr2 <- taxmapper(idtax.silva.pretty,
                      tt.ranks = colnames(idtax.silva.pretty)[2:ncol(idtax.silva.pretty)],
                      tax2map2 = "pr2",
                      exceptions = c("Archaea", "Bacteria"),
                      ignore.format = TRUE,
                      synonym.file = "default",
                      streamline = TRUE,
                      outfilez = NULL)
head(idtax.silva.mapped2pr2)
```

    ##       svN   kingdom    supergroup   division  class   order family genus
    ## 1 sv14136 Eukaryota          <NA>       <NA>   <NA>    <NA>   <NA>  <NA>
    ## 2 sv17278 Eukaryota Stramenopiles Ochrophyta MOCH-2    <NA>   <NA>  <NA>
    ## 3 sv20747 Eukaryota          <NA>       <NA>   <NA>    <NA>   <NA>  <NA>
    ## 4  sv3579 Eukaryota          <NA>       <NA>   <NA>    <NA>   <NA>  <NA>
    ## 5  sv4298 Eukaryota Stramenopiles   Opalozoa MAST-3 MAST-3B   <NA>  <NA>
    ##   species
    ## 1    <NA>
    ## 2    <NA>
    ## 3    <NA>
    ## 4    <NA>
    ## 5    <NA>

Inspection of the mapped taxonomy table shows that it now mirrors the naming and ranking conventions of the other two taxonomy tables.

#### The ensembleTax algorithm

Now we have three different taxonomy tables with independent taxonomic assignments for each ASV in our example data set. From these we can compute ensemble taxonomic assignments with the *ensembleTax* algorithm.

Here's a run with the default parameters:

``` r
xx <- list(idtax.pr2.pretty, idtax.silva.mapped2pr2, bayes.pr2.pretty)
names(xx) <- c("idtax-pr2", "idtax-silva", "bayes-pr2")
eTax1 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = "none", 
                     count.na=TRUE, 
                     assign.threshold = 0, 
                     weights=rep(1,length(xx)))
head(eTax1)
```

    ##       svN   kingdom    supergroup   division           class             order
    ## 1 sv14136 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 2 sv17278 Eukaryota Stramenopiles Ochrophyta          MOCH-2              <NA>
    ## 3 sv20747 Eukaryota Stramenopiles Ochrophyta Bacillariophyta Bacillariophyta_X
    ## 4  sv3579 Eukaryota          <NA>       <NA>            <NA>              <NA>
    ## 5  sv4298 Eukaryota Stramenopiles   Opalozoa          MAST-3           MAST-3B
    ##                       family       genus species
    ## 1 Polar-centric-Mediophyceae        <NA>    <NA>
    ## 2                       <NA>        <NA>    <NA>
    ## 3 Polar-centric-Mediophyceae Chaetoceros    <NA>
    ## 4                       <NA>        <NA>    <NA>
    ## 5                       <NA>        <NA>    <NA>

We see that the assignments made at the highest frequency across the 3 assignment algorithms are assigned as the ensemble taxonomic assignment. *NA* is counted as a taxonomic name because we've set *count.na = TRUE*.

We'll get different ensemble taxonomic assignments if we set *count.na = FALSE*, as you can see below:

``` r
xx <- list(idtax.pr2.pretty, idtax.silva.mapped2pr2, bayes.pr2.pretty)
names(xx) <- c("idtax-pr2", "idtax-silva", "bayes-pr2")
eTax2 <- ensembleTax(xx, 
                     tablenames = names(xx), 
                     ranknames = c("kingdom", "supergroup", "division","class","order","family","genus","species"),
                     tiebreakz = "none", 
                     count.na=FALSE, 
                     assign.threshold = 0, 
                     weights=rep(1,length(xx)))
head(eTax2)
```

    ##       svN   kingdom     supergroup     division           class
    ## 1 sv14136 Eukaryota  Stramenopiles   Ochrophyta Bacillariophyta
    ## 2 sv17278 Eukaryota  Stramenopiles   Ochrophyta          MOCH-2
    ## 3 sv20747 Eukaryota  Stramenopiles   Ochrophyta Bacillariophyta
    ## 4  sv3579 Eukaryota Archaeplastida Streptophyta   Embryophyceae
    ## 5  sv4298 Eukaryota  Stramenopiles     Opalozoa          MAST-3
    ##               order                     family       genus        species
    ## 1 Bacillariophyta_X Polar-centric-Mediophyceae  Minidiscus Minidiscus_sp.
    ## 2          MOCH-2_X                  MOCH-2_XX  MOCH-2_XXX MOCH-2_XXX_sp.
    ## 3 Bacillariophyta_X Polar-centric-Mediophyceae Chaetoceros           <NA>
    ## 4   Embryophyceae_X           Embryophyceae_XX        <NA>           <NA>
    ## 5           MAST-3B                  MAST-3B_X  MAST-3B_XX MAST-3B_XX_sp.

You'll notice the resolution of assignments is much greater when not counting NA assignments. It should be noted that this likely comes at the cost of higher over-classification error rates, while setting *count.na = TRUE* would be expected to minimize over-classification errors but maximize under-classification errors.

Optimal ensemble assignment parameters will depend on your scientific question, so hopefully you'll poke around with a few different settings and see what makes sense.

Anyhow, that's it, let us know on the issues page if/when you find bugs!
